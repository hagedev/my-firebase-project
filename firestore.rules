/**
 * @fileoverview Firestore Security Rules for AirCafe.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant data model with role-based access control.
 * Users are associated with a specific tenant and can have either 'admin_kafe' or 'superadmin' roles.
 * Superadmins have global read access, while tenant admins have read/write access only within their tenant.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant-specific data.
 * - /users/{userId}: Stores user profiles.
 * - /roles_superadmin/{userId}:  Used to identify superadmin roles.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items for each tenant.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories for each tenant.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders for each tenant.
 * - /tenants/{tenantId}/tables/{tableId}: Stores table information for each tenant.
 *
 * Key Security Decisions:
 * - Superadmins can read all data (used for global analytics or moderation).
 * - Tenant admins have full CRUD access only within their assigned tenant.
 * - Users cannot list all users (privacy).
 * - Data shape validation is relaxed during the prototyping phase, focusing on authorization and relational integrity.
 *
 * Denormalization for Authorization:
 *  - User documents include a 'tenantId' field, allowing rules to quickly check tenant membership without additional reads.
 *  - User documents include a 'role' field, allowing rules to quickly check role-based permissions without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner (UID matches).
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is a superadmin by verifying their UID exists in the roles_superadmin collection.
     */
    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    /**
     * @description Checks if the user is an admin of the specified tenant.
     */
    function isTenantAdmin(tenantId) {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin_kafe';
    }

    /**
     * @description Checks if the user is an existing owner of a resource.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource.data != null;
    }

    /**
     * @description Rules for the /tenants/{tenantId} collection.
     * @path /tenants/{tenantId}
     * @allow (get, list) if isSuperAdmin() - Superadmin can read tenant data.
     * @allow (create) if isSignedIn() && request.resource.data.id == request.auth.uid // TODO: Add admin role check
     * @allow (update, delete) if isTenantAdmin(tenantId) - Tenant admin can update/delete within their tenant.
     * @deny (get) if !isSignedIn() - Non-signed-in users cannot read tenant data.
     * @principle Enforces role-based access for tenant management.
     */
    match /tenants/{tenantId} {
      allow get, list: if isSuperAdmin();
      allow create: if false; // Tenant creation should happen via backend admin functions, not directly by users
      allow update, delete: if false; // Tenant updates & deletes not allowed in prototyping mode

      /**
       * @description Rules for the /tenants/{tenantId}/menus/{menuId} collection.
       * @path /tenants/{tenantId}/menus/{menuId}
       * @allow (get, list) if isSuperAdmin() || isTenantAdmin(tenantId) - Superadmin or tenant admin can read menus.
       * @allow (create, update, delete) if isTenantAdmin(tenantId) - Tenant admin can create/update/delete within their tenant.
       * @deny (create) if request.resource.data.tenantId != tenantId - Tenant ID in data must match path.
       * @principle Enforces tenant-specific access for menu management.
       */
      match /menus/{menuId} {
        allow get, list: if isSuperAdmin() || isTenantAdmin(tenantId);
        allow create: if isTenantAdmin(tenantId);
        allow update, delete: if isTenantAdmin(tenantId);
      }

      /**
       * @description Rules for the /tenants/{tenantId}/categories/{categoryId} collection.
       * @path /tenants/{tenantId}/categories/{categoryId}
       * @allow (get, list) if isSuperAdmin() || isTenantAdmin(tenantId) - Superadmin or tenant admin can read categories.
       * @allow (create, update, delete) if isTenantAdmin(tenantId) - Tenant admin can create/update/delete within their tenant.
       * @principle Enforces tenant-specific access for category management.
       */
      match /categories/{categoryId} {
        allow get, list: if isSuperAdmin() || isTenantAdmin(tenantId);
        allow create: if isTenantAdmin(tenantId);
        allow update, delete: if isTenantAdmin(tenantId);
      }

      /**
       * @description Rules for the /tenants/{tenantId}/orders/{orderId} collection.
       * @path /tenants/{tenantId}/orders/{orderId}
       * @allow (get, list) if isSuperAdmin() || isTenantAdmin(tenantId) - Superadmin or tenant admin can read orders.
       * @allow (create, update, delete) if isTenantAdmin(tenantId) - Tenant admin can create/update/delete within their tenant.
       * @principle Enforces tenant-specific access for order management.
       */
      match /orders/{orderId} {
        allow get, list: if isSuperAdmin() || isTenantAdmin(tenantId);
        allow create: if isTenantAdmin(tenantId);
        allow update, delete: if isTenantAdmin(tenantId);
      }

      /**
       * @description Rules for the /tenants/{tenantId}/tables/{tableId} collection.
       * @path /tenants/{tenantId}/tables/{tableId}
       * @allow (get, list) if isSuperAdmin() || isTenantAdmin(tenantId) - Superadmin or tenant admin can read tables.
       * @allow (create, update, delete) if isTenantAdmin(tenantId) - Tenant admin can create/update/delete within their tenant.
       * @principle Enforces tenant-specific access for table management.
       */
      match /tables/{tableId} {
        allow get, list: if isSuperAdmin() || isTenantAdmin(tenantId);
        allow create: if isTenantAdmin(tenantId);
        allow update, delete: if isTenantAdmin(tenantId);
      }
    }

    /**
     * @description Rules for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (get) if isOwner(userId) || isSuperAdmin() - Owner or superadmin can read user profile.
     * @allow (create) if isOwner(userId) - User can create their own profile.
     * @allow (update, delete) if isOwner(userId) - User can update/delete their own profile.
     * @deny (list) if true - Listing all users is not allowed for privacy.
     * @deny (create) if request.auth.uid != userId - User ID must match auth UID for creation.
     * @principle Enforces user ownership and prevents unauthorized access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isSuperAdmin();
      allow list: if false;
      allow create: if request.auth.uid == userId;
      allow update, delete: if isOwner(userId);
    }

    /**
     * @description Rules for the /roles_superadmin/{userId} collection.
     *              This collection is used to manage superadmin roles.
     * @path /roles_superadmin/{userId}
     * @allow (get) if isSuperAdmin() - Superadmin can read roles.
     * @allow (list) if false - Prevent listing all superadmin roles.
     * @allow (create, update, delete) if false - Prevent creating, updating, or deleting roles via client.
     * @principle Superadmin roles are managed through secure backend functions.
     */
    match /roles_superadmin/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false;
      allow create, update, delete: if false;
    }
  }
}