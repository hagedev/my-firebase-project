/**
 * @description This ruleset enforces a multi-tenant security model for the AirCafe application.
 *              It provides granular access control based on user roles (superadmin, tenant admin) and tenant ownership.
 * @dataStructure
 *  - /tenants/{tenantId}: Stores tenant-specific data, accessible to superadmins and tenant admins.
 *  - /users/{userId}: Stores user profiles, including role and tenant assignment.
 *  - /tenants/{tenantId}/menus/{menuId}: Stores menu items for each tenant.
 *  - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories for each tenant.
 *  - /tenants/{tenantId}/orders/{orderId}: Stores orders placed at each tenant.
 *  - /tenants/{tenantId}/tables/{tableId}: Stores tables for each tenant.
 *  - /roles_superadmin/{userId}: Documents in this collection denote superadmin privileges.
 * @keySecurityDecisions
 *  - Superadmins have full access to all tenant data, enabled by role-based access control (DBAC) via `/roles_superadmin/{userId}`.
 *  - Tenant admins can only manage data within their assigned tenant.
 *  - Unauthenticated users can list menus and categories for a specific tenant.
 *  - The `users` collection is strictly owner-only for `get` and `update` operations. Listing of users is forbidden.
 * @denormalizationForAuthorization
 *  - The `tenantId` is duplicated in all subcollections (menus, categories, tables, orders) under the tenants document. This allows security rules to efficiently validate tenant-level access without requiring `get()` calls to the tenant document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows superadmins to read tenants collection for listing purposes.
     * @path /tenants/{tenantId}
     * @allow (get) Request from a superadmin to get a tenant document.
     * @deny (get) Request from a non-superadmin to get a tenant document.
     * @principle Superadmins can manage all tenants.
     */
    match /tenants/{tenantId} {
      allow get: if true;
      allow list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages user profiles. Only the owner can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates their own profile with data.id = 'user123'.
     * @deny (create) User with UID 'user123' attempts to create a profile with data.id = 'user456'.
     * @allow (get) User with UID 'user123' reads their own profile.
     * @deny (get) User with UID 'user123' attempts to read profile of 'user456'.
     * @allow (update) User with UID 'user123' updates their own profile, maintaining data.id = 'user123'.
     * @deny (update) User with UID 'user123' attempts to update the profile of 'user456'.
     * @principle Enforces strict user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if false;
    }

    /**
     * @description Manages menu items for a specific tenant.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (get) Anyone can read a menu item.
     * @allow (list) Anyone can list menu items.
     * @deny (create) Non-admins cannot create menu items.
     * @principle Menu items are publicly readable, but only tenant admins can manage them.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdminKafe(tenantId);
      allow update: if isExistingAdminKafe(tenantId);
      allow delete: if isExistingAdminKafe(tenantId);
    }

    /**
     * @description Manages menu categories for a specific tenant.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (get) Anyone can read a category.
     * @allow (list) Anyone can list categories.
     * @deny (create) Non-admins cannot create categories.
     * @principle Menu categories are publicly readable, but only tenant admins can manage them.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdminKafe(tenantId);
      allow update: if isExistingAdminKafe(tenantId);
      allow delete: if isExistingAdminKafe(tenantId);
    }

    /**
     * @description Manages orders placed at a specific tenant.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (create) Tenant admins can create orders.
     * @allow (get) Tenant admins and superadmins can get orders.
     * @allow (update) Tenant admins can update orders.
     * @allow (delete) Tenant admins can delete orders.
     * @principle Orders are managed by tenant admins and superadmins.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get: if isAdminKafe(tenantId) || isSuperAdmin();
      allow list: if isAdminKafe(tenantId) || isSuperAdmin();
      allow create: if isAdminKafe(tenantId) && request.resource.data.verificationToken == get(/databases/$(database)/documents/tenants/$(tenantId)).data.tokenHarian;
      allow update: if isExistingAdminKafe(tenantId);
      allow delete: if isExistingAdminKafe(tenantId);
    }

    /**
     * @description Manages tables for a specific tenant.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (get) Tenant admins and superadmins can get tables.
     * @allow (list) Tenant admins and superadmins can list tables.
     * @allow (create) Tenant admins can create tables.
     * @allow (update) Tenant admins can update tables.
     * @allow (delete) Tenant admins can delete tables.
     * @principle Tables are managed by tenant admins and superadmins.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get: if isAdminKafe(tenantId) || isSuperAdmin();
      allow list: if isAdminKafe(tenantId) || isSuperAdmin();
      allow create: if isAdminKafe(tenantId);
      allow update: if isExistingAdminKafe(tenantId);
      allow delete: if isExistingAdminKafe(tenantId);
    }

    /**
     * @description Collection to store superadmin user IDs for role-based access control (DBAC).
     * @path /roles_superadmin/{userId}
     * @allow (create) Only Firebase Auth can create superadmin roles.
     * @allow (get) Any signed-in user can check for superadmin status.
     * @deny (update) No one can update the role.
     * @deny (delete) Only Firebase Auth can delete the role.
     * @principle DBAC via existence check in /roles_superadmin/{userId}.
     */
    match /roles_superadmin/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    function isAdminKafe(tenantId) {
        return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin_kafe' || isSuperAdmin();
    }

    function isExistingAdminKafe(tenantId) {
        return isAdminKafe(tenantId) && resource != null;
    }
  }
}