/**
 * @fileoverview Firestore Security Rules for AirCafe application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model. Users can only access data
 * associated with their assigned tenant, unless they have superadmin privileges.
 * Data ownership is validated at each level of the data hierarchy, and
 * denormalization is used extensively to avoid complex queries in security rules.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant-specific information.
 * - /users/{userId}: Stores user profiles, including tenant ID and role.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items for each tenant.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders placed at each tenant.
 * - /tenants/{tenantId}/tables/{tableId}: Stores table information.
 * - /roles_superadmin/{userId}: Documents in this collection grant superadmin privileges to the user.
 *
 * Key Security Decisions:
 * - Users can only list data within their tenant context, unless they are superadmins.
 * - Superadmin privileges are determined by the existence of a document in the `/roles_superadmin/{userId}` collection.
 * - The `tenantId` is denormalized into subcollections to simplify authorization checks.
 * - The `verificationToken` for orders is validated against the tenant's `tokenHarian` during order creation, mitigating spam.
 * - Listing of all users is disallowed.
 *
 * Denormalization for Authorization:
 * - The `tenantId` field is present in all subcollections under `/tenants/{tenantId}` (menus, categories, orders, tables) to allow direct authorization checks without requiring additional `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to tenant documents based on superadmin privileges.
     * @path /tenants/{tenantId}
     * @allow (get, list): If the user is a superadmin.
     * @allow (create, update, delete): Never, updates are disallowed via rules.
     * @deny (get, list): If the user is not a superadmin.
     * @principle Role-based access control for tenants.
     */
    match /tenants/{tenantId} {
      allow get, list: if isSuperAdmin();
      allow create, update, delete: if false;
    }

    /**
     * @description Manages user profiles, accessible only by superadmins or the user themselves.
     * @path /users/{userId}
     * @allow (get): If the user is a superadmin or the owner of the profile.
     * @allow (create): If the user's UID matches the document ID.
     * @allow (update, delete): If the user is a superadmin or the owner of the profile and the document exists.
     * @deny (get): If the user is not a superadmin and not the owner of the profile.
     * @deny (create): If the user's UID does not match the document ID.
     * @deny (update, delete): If the user is not a superadmin, not the owner of the profile, or the document does not exist.
     * @principle Enforces user-level access control and administrative override.
     */
    match /users/{userId} {
      allow get: if isSuperAdmin() || isOwner(userId);
      allow list: if false; // Disallowing listing of all users.
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if (isSuperAdmin() || isExistingOwner(userId)) && request.resource.data.id == resource.data.id; //Immutable id
      allow delete: if isSuperAdmin() || isExistingOwner(userId);
    }

    /**
     * @description Manages menu items for a specific tenant.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (get, list): If the user is a superadmin or belongs to the tenant.
     * @allow (create): If the user is a superadmin or belongs to the tenant, and the 'tenantId' field matches the path.
     * @allow (update, delete): If the user is a superadmin or the owner of the tenant and the document exists.
     * @deny (get, list): If the user is not a superadmin and does not belong to the tenant.
     * @deny (create): If the user is not a superadmin and does not belong to the tenant, or the 'tenantId' field does not match the path.
     * @deny (update, delete): If the user is not a superadmin or the owner of the tenant, or the document does not exist.
     * @principle Tenant-specific menu management.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get, list: if isSuperAdmin() || isTenant(tenantId);
      allow create: if (isSuperAdmin() || isTenant(tenantId)) && request.resource.data.tenantId == tenantId;
      allow update: if (isSuperAdmin() || isExistingTenant(tenantId)) && request.resource.data.tenantId == tenantId; //Immutable tenantId
      allow delete: if isSuperAdmin() || isExistingTenant(tenantId);
    }

    /**
     * @description Manages menu categories for a specific tenant.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (get, list): If the user is a superadmin or belongs to the tenant.
     * @allow (create): If the user is a superadmin or belongs to the tenant, and the 'tenantId' field matches the path.
     * @allow (update, delete): If the user is a superadmin or the owner of the tenant and the document exists.
     * @deny (get, list): If the user is not a superadmin and does not belong to the tenant.
     * @deny (create): If the user is not a superadmin and does not belong to the tenant, or the 'tenantId' field does not match the path.
     * @deny (update, delete): If the user is not a superadmin or the owner of the tenant, or the document does not exist.
     * @principle Tenant-specific category management.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get, list: if isSuperAdmin() || isTenant(tenantId);
      allow create: if (isSuperAdmin() || isTenant(tenantId)) && request.resource.data.tenantId == tenantId;
      allow update: if (isSuperAdmin() || isExistingTenant(tenantId)) && request.resource.data.tenantId == tenantId; //Immutable tenantId
      allow delete: if isSuperAdmin() || isExistingTenant(tenantId);
    }

    /**
     * @description Manages orders placed at a specific tenant.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (get, list): If the user is a superadmin or belongs to the tenant.
     * @allow (create): If the user is a superadmin or belongs to the tenant, the 'tenantId' field matches the path, and the verification token matches the tenant's daily token.
     * @allow (update, delete): If the user is a superadmin or the owner of the tenant and the document exists.
     * @deny (get, list): If the user is not a superadmin and does not belong to the tenant.
     * @deny (create): If the user is not a superadmin and does not belong to the tenant, the 'tenantId' field does not match the path, or the verification token does not match the tenant's daily token.
     * @deny (update, delete): If the user is not a superadmin or the owner of the tenant, or the document does not exist.
     * @principle Tenant-specific order management with anti-spam verification.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get, list: if isSuperAdmin() || isTenant(tenantId);
      allow create: if (isSuperAdmin() || isTenant(tenantId))
                      && request.resource.data.tenantId == tenantId
                      && isValidVerificationToken(tenantId, request.resource.data.verificationToken);
      allow update: if (isSuperAdmin() || isExistingTenant(tenantId)) && request.resource.data.tenantId == tenantId; //Immutable tenantId
      allow delete: if isSuperAdmin() || isExistingTenant(tenantId);
    }

    /**
     * @description Manages tables for a specific tenant.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (get, list): If the user is a superadmin or belongs to the tenant.
     * @allow (create): If the user is a superadmin or belongs to the tenant, and the 'tenantId' field matches the path.
     * @allow (update, delete): If the user is a superadmin or the owner of the tenant and the document exists.
     * @deny (get, list): If the user is not a superadmin and does not belong to the tenant.
     * @deny (create): If the user is not a superadmin and does not belong to the tenant, or the 'tenantId' field does not match the path.
     * @deny (update, delete): If the user is not a superadmin or the owner of the tenant, or the document does not exist.
     * @principle Tenant-specific table management.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get, list: if isSuperAdmin() || isTenant(tenantId);
      allow create: if (isSuperAdmin() || isTenant(tenantId)) && request.resource.data.tenantId == tenantId;
      allow update: if (isSuperAdmin() || isExistingTenant(tenantId)) && request.resource.data.tenantId == tenantId; //Immutable tenantId
      allow delete: if isSuperAdmin() || isExistingTenant(tenantId);
    }

    /**
     * @description Grants superadmin privileges based on the existence of a document.
     * @path /roles_superadmin/{userId}
     * @allow (get, create, update, delete): Only if the user's UID matches the document ID.
     * @deny (get, create, update, delete): If the user's UID does not match the document ID.
     */
    match /roles_superadmin/{userId} {
      allow get, create, update, delete: if isSignedIn() && request.auth.uid == userId;
      allow list: if false; // Listing all superadmins is disallowed.
    }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the document and the document exists.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user belongs to the specified tenant.
     * @param {string} tenantId The tenant ID to check against.
     * @return {boolean} True if the user belongs to the tenant, false otherwise.
     */
    function isTenant(tenantId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
    }

    /**
     * @description Checks if the resource exists and the user belongs to the specified tenant.
     * @param {string} tenantId The tenant ID to check against.
     * @return {boolean} True if the user belongs to the tenant and the resource exists, false otherwise.
     */
    function isExistingTenant(tenantId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId && resource != null;
    }

    /**
     * @description Checks if the user is a superadmin by verifying the existence of a document in the /roles_superadmin/{userId} collection.
     * @return {boolean} True if the user is a superadmin, false otherwise.
     */
    function isSuperAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    /**
     * @description Validates if the verification token matches the tenant's daily token.
     * @param {string} tenantId The tenant ID.
     * @param {string} verificationToken The verification token from the order.
     * @return {boolean} True if the token is valid, false otherwise.
     */
    function isValidVerificationToken(tenantId, verificationToken) {
      return get(/databases/$(database)/documents/tenants/$(tenantId)).data.tokenHarian == verificationToken;
    }
  }
}