/**
 * @file Firebase Security Rules for AirCafe Application
 *
 * @description This ruleset enforces a multi-tenant security model for the AirCafe application.
 *              It provides role-based access control (superadmin, admin_kafe) and allows anonymous
 *              users to create orders with token verification. Data is segregated by tenant,
 *              and ownership is validated where appropriate.
 *
 * @dataStructure
 *  - /tenants/{tenantId}: Stores cafe profiles. Accessible by superadmin and the owning admin_kafe.
 *  - /users/{userId}: Stores user information (role, tenantId). Accessible by superadmin.
 *  - /tenants/{tenantId}/menus/{menuId}: Stores menu items. Accessible by admin_kafe within their tenant.
 *  - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories. Accessible by admin_kafe within their tenant.
 *  - /tenants/{tenantId}/orders/{orderId}: Stores orders. Accessible by admin_kafe within their tenant. Customers can create with token verification.
 *  - /tenants/{tenantId}/tables/{tableId}: Stores table information. Accessible by admin_kafe within their tenant.
 *  - /roles_superadmin/{userId}: Indicates superadmin privileges. Locked from client-side writes.
 *
 * @keySecurityDecisions
 *  - Superadmins have full CRUD access to tenants and users.
 *  - admin_kafe users have CRUD access only within their assigned tenant.
 *  - Anonymous users can create orders with a valid verification token.
 *  - User listing is disabled to prevent information disclosure.
 *  - Superadmin role locked from client side
 *
 * @denormalizationForAuthorization
 *  - User documents store tenantId for efficient role-based access control.
 *  - Order documents store tenantId to enable independent authorization.
 *
 * @structuralSegregation
 *  - No public collections are used, access is limited to auth'd users only
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided user ID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if a user is a superadmin by verifying the existence of a superadmin role document.
     */
    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    /**
     * @description Checks if the authenticated user is an admin_kafe and owns the resource.
     */
    function isAdminKafeForTenant(tenantId) {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin_kafe'
          && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
    }

    /**
     * @description Combines the ownership check with the existence check for destructive operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description
     * @path /tenants/{tenantId}
     * @allow (create) request.auth.uid with isSuperAdmin() and valid data
     * @allow (get) request.auth.uid with isSuperAdmin()
     * @deny (create) request.auth.uid without superadmin role
     * @principle Enforces superadmin-only access for tenant creation.
     */
    match /tenants/{tenantId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin() || (isSignedIn() && isAdminKafeForTenant(tenantId));
      allow delete: if isSuperAdmin();
    }

    /**
     * @description
     * @path /users/{userId}
     * @allow (create) request.auth.uid with isSuperAdmin() and valid data
     * @allow (get) request.auth.uid with isSuperAdmin()
     * @deny (create) request.auth.uid without superadmin role
     * @principle Enforces superadmin-only access for user creation and management.
     */
    match /users/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false;
      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin();
      allow delete: if isSuperAdmin();
    }

    /**
     * @description
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (create) request.auth.uid with isAdminKafeForTenant(tenantId) and valid data
     * @allow (get) request.auth.uid with isAdminKafeForTenant(tenantId)
     * @deny (create) request.auth.uid without admin_kafe role or incorrect tenantId
     * @principle Enforces admin_kafe-only access for menu management within their tenant.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow list: if false;
      allow create: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow update: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow delete: if isSignedIn() && isAdminKafeForTenant(tenantId);
    }

    /**
     * @description
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (create) request.auth.uid with isAdminKafeForTenant(tenantId) and valid data
     * @allow (get) request.auth.uid with isAdminKafeForTenant(tenantId)
     * @deny (create) request.auth.uid without admin_kafe role or incorrect tenantId
     * @principle Enforces admin_kafe-only access for category management within their tenant.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow list: if false;
      allow create: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow update: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow delete: if isSignedIn() && isAdminKafeForTenant(tenantId);
    }

    /**
     * @description
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (create) request.auth with verification token and valid data
     * @allow (get) request.auth.uid with isAdminKafeForTenant(tenantId)
     * @deny (create) request.auth without verification token or invalid token
     * @principle Allows order creation with token verification and admin_kafe access within their tenant.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow list: if false;
      allow create: if request.resource.data.verificationToken == get(/databases/$(database)/documents/tenants/$(tenantId)).data.tokenHarian;
      allow update: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow delete: if isSignedIn() && isAdminKafeForTenant(tenantId);
    }

    /**
     * @description
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (get) request.auth.uid with isAdminKafeForTenant(tenantId)
     * @allow (update) request.auth.uid with isAdminKafeForTenant(tenantId) and valid data
     * @deny (create, delete) request.auth
     * @principle Enforces admin_kafe-only access for table management within their tenant.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow list: if false;
      allow create: if false;
      allow update: if isSignedIn() && isAdminKafeForTenant(tenantId);
      allow delete: if false;
    }

    /**
     * @description
     * @path /roles_superadmin/{userId}
     * @deny All client-side operations.  This collection is managed server-side.
     * @principle Superadmin role cannot be changed by client
     */
    match /roles_superadmin/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if isSuperAdmin();
    }
  }
}