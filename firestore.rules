/**
 * @fileoverview Firestore Security Rules for AirCafe application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant data model with role-based access control.
 * Superadmins have full access to all data, while admin_kafe users are restricted
 * to managing data within their assigned tenant. Anonymous users can create orders
 * after token verification. All writes are strictly controlled, and data
 * consistency is enforced where necessary.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores cafe profiles. Accessible by superadmins and the tenant admin.
 * - /users/{userId}: Stores user information. Accessible only by superadmins.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items. Accessible by the tenant admin.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories. Accessible by the tenant admin.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders. Accessible by the tenant admin and customers with token verification.
 * - /tenants/{tenantId}/tables/{tableId}: Stores table information. Accessible by the tenant admin.
 * - /roles_superadmin/{userId}: Indicates superadmin privileges. Only readable by the user.
 *
 * Key Security Decisions:
 * - Superadmins bypass tenant-level restrictions.
 * - Admin_kafe users are restricted to their own tenant's data.
 * - Anonymous users can only create orders with a valid verification token.
 * - User listing is disallowed.
 * - The `roles_superadmin` collection is locked from client-side writes.
 *
 * Denormalization for Authorization:
 * - User documents contain the tenantId and role for simplified access control.
 * - Order documents contain the tenantId, tableId and verificationToken to avoid complex queries.
 *
 * Structural Segregation:
 * - No public data collections are used. All data is either tenant-specific or role-restricted.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @param none
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

     /**
     * @description Checks if the user is an existing owner of the resource.
     * @param {string} userId - The user ID to compare against the resource's ID.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the user is a superadmin based on the existence of a document in roles_superadmin.
     * @return {boolean} True if the user is a superadmin, false otherwise.
     */
    function isSuperAdmin() {
        return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    /**
     * @description Checks if the user is an admin_kafe for the given tenant.
     * @param {string} tenantId - The tenant ID to check against the user's tenant ID.
     * @return {boolean} True if the user is an admin_kafe for the tenant, false otherwise.
     */
    function isAdminKafe(tenantId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin_kafe' && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
    }

    /**
     * @description Match block for the /tenants/{tenantId} collection.
     * @path /tenants/{tenantId}
     * @allow (get) User with ID 'superadmin_user' (superadmin) can access tenant with ID 'tenant123'.
     * @allow (create) User with ID 'superadmin_user' (superadmin) can create tenant with ID 'tenant123'.
     * @allow (update) User with ID 'superadmin_user' (superadmin) can update tenant with ID 'tenant123'.
     * @allow (delete) User with ID 'superadmin_user' (superadmin) can delete tenant with ID 'tenant123'.
     * @allow (get) User with ID 'admin_kafe_user' (admin_kafe) can access their own tenant with ID 'tenant456'.
     * @allow (update) User with ID 'admin_kafe_user' (admin_kafe) can update their own tenant with ID 'tenant456'.
     * @deny (get) User with ID 'random_user' (non-admin) cannot access tenant with ID 'tenant123'.
     * @deny (create) User with ID 'random_user' (non-admin) cannot create tenant with ID 'tenant123'.
     * @deny (update) User with ID 'random_user' (non-admin) cannot update tenant with ID 'tenant123'.
     * @deny (delete) User with ID 'random_user' (non-admin) cannot delete tenant with ID 'tenant123'.
     * @principle Enforces tenant-level access control, allowing superadmins full access and admin_kafe users access to their own tenant.
     */
    match /tenants/{tenantId} {
      allow get: if isSuperAdmin() || (isSignedIn() && isAdminKafe(tenantId));
      allow list: if false;
      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin() || (isSignedIn() && isAdminKafe(tenantId));
      allow delete: if isSuperAdmin();
    }

    /**
     * @description Match block for the /users/{userId} collection.
     * @path /users/{userId}
     * @allow (get) User with ID 'superadmin_user' (superadmin) can access user with ID 'user123'.
     * @allow (create) User with ID 'superadmin_user' (superadmin) can create user with ID 'user123'.
     * @allow (update) User with ID 'superadmin_user' (superadmin) can update user with ID 'user123'.
     * @allow (delete) User with ID 'superadmin_user' (superadmin) can delete user with ID 'user123'.
     * @deny (get) User with ID 'random_user' (non-admin) cannot access user with ID 'user123'.
     * @deny (create) User with ID 'random_user' (non-admin) cannot create user with ID 'user123'.
     * @deny (update) User with ID 'random_user' (non-admin) cannot update user with ID 'user123'.
     * @deny (delete) User with ID 'random_user' (non-admin) cannot delete user with ID 'user123'.
     * @principle Restricts user management to superadmins only.
     */
    match /users/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false;
      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin();
      allow delete: if isSuperAdmin();
    }

    /**
     * @description Match block for the /tenants/{tenantId}/menus/{menuId} collection.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (get) User with ID 'admin_kafe_user' (admin_kafe) can access menu with ID 'menu123' in their tenant with ID 'tenant456'.
     * @allow (create) User with ID 'admin_kafe_user' (admin_kafe) can create menu with ID 'menu123' in their tenant with ID 'tenant456'.
     * @allow (update) User with ID 'admin_kafe_user' (admin_kafe) can update menu with ID 'menu123' in their tenant with ID 'tenant456'.
     * @allow (delete) User with ID 'admin_kafe_user' (admin_kafe) can delete menu with ID 'menu123' in their tenant with ID 'tenant456'.
     * @deny (get) User with ID 'random_user' (non-admin) cannot access menu with ID 'menu123' in tenant with ID 'tenant456'.
     * @deny (create) User with ID 'random_user' (non-admin) cannot create menu with ID 'menu123' in tenant with ID 'tenant456'.
     * @deny (update) User with ID 'random_user' (non-admin) cannot update menu with ID 'menu123' in tenant with ID 'tenant456'.
     * @deny (delete) User with ID 'random_user' (non-admin) cannot delete menu with ID 'menu123' in tenant with ID 'tenant456'.
     * @principle Enforces tenant-level access control for menu items, allowing admin_kafe users to manage menus within their tenant.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get: if isAdminKafe(tenantId);
      allow list: if false;
      allow create: if isAdminKafe(tenantId);
      allow update: if isAdminKafe(tenantId);
      allow delete: if isAdminKafe(tenantId);
    }

    /**
     * @description Match block for the /tenants/{tenantId}/categories/{categoryId} collection.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (get) User with ID 'admin_kafe_user' (admin_kafe) can access category with ID 'category123' in their tenant with ID 'tenant456'.
     * @allow (create) User with ID 'admin_kafe_user' (admin_kafe) can create category with ID 'category123' in their tenant with ID 'tenant456'.
     * @allow (update) User with ID 'admin_kafe_user' (admin_kafe) can update category with ID 'category123' in their tenant with ID 'tenant456'.
     * @allow (delete) User with ID 'admin_kafe_user' (admin_kafe) can delete category with ID 'category123' in their tenant with ID 'tenant456'.
     * @deny (get) User with ID 'random_user' (non-admin) cannot access category with ID 'category123' in tenant with ID 'tenant456'.
     * @deny (create) User with ID 'random_user' (non-admin) cannot create category with ID 'category123' in tenant with ID 'tenant456'.
     * @deny (update) User with ID 'random_user' (non-admin) cannot update category with ID 'category123' in tenant with ID 'tenant456'.
     * @deny (delete) User with ID 'random_user' (non-admin) cannot delete category with ID 'category123' in tenant with ID 'tenant456'.
     * @principle Enforces tenant-level access control for menu categories, allowing admin_kafe users to manage categories within their tenant.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get: if isAdminKafe(tenantId);
      allow list: if false;
      allow create: if isAdminKafe(tenantId);
      allow update: if isAdminKafe(tenantId);
      allow delete: if isAdminKafe(tenantId);
    }

    /**
     * @description Match block for the /tenants/{tenantId}/orders/{orderId} collection.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (get) User with ID 'admin_kafe_user' (admin_kafe) can access order with ID 'order123' in their tenant with ID 'tenant456'.
     * @allow (create) Anonymous user can create order with ID 'order123' if verification token matches.
     * @allow (update) User with ID 'admin_kafe_user' (admin_kafe) can update order with ID 'order123' in their tenant with ID 'tenant456'.
     * @allow (delete) User with ID 'admin_kafe_user' (admin_kafe) can delete order with ID 'order123' in their tenant with ID 'tenant456'.
     * @deny (get) User with ID 'random_user' (non-admin) cannot access order with ID 'order123' in tenant with ID 'tenant456'.
     * @deny (create) Anonymous user cannot create order if verification token does not match.
     * @deny (update) User with ID 'random_user' (non-admin) cannot update order with ID 'order123' in tenant with ID 'tenant456'.
     * @deny (delete) User with ID 'random_user' (non-admin) cannot delete order with ID 'order123' in tenant with ID 'tenant456'.
     * @principle Enforces tenant-level access control for orders, allowing admin_kafe users to manage orders within their tenant and anonymous users to create orders with token verification.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get: if isAdminKafe(tenantId);
      allow list: if false;
      allow create: if request.auth == null && request.resource.data.tenantId == tenantId && request.resource.data.verificationToken == get(/databases/$(database)/documents/tenants/$(tenantId)).data.tokenHarian;
      allow update: if isAdminKafe(tenantId);
      allow delete: if isAdminKafe(tenantId);
    }

    /**
     * @description Match block for the /tenants/{tenantId}/tables/{tableId} collection.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (get) User with ID 'admin_kafe_user' (admin_kafe) can access table with ID 'table123' in their tenant with ID 'tenant456'.
     * @allow (update) User with ID 'admin_kafe_user' (admin_kafe) can update table with ID 'table123' in their tenant with ID 'tenant456'.
     * @deny (get) User with ID 'random_user' (non-admin) cannot access table with ID 'table123' in tenant with ID 'tenant456'.
     * @deny (create) User with ID 'random_user' (non-admin) cannot create table with ID 'table123' in tenant with ID 'tenant456'.
     * @deny (delete) User with ID 'random_user' (non-admin) cannot delete table with ID 'table123' in tenant with ID 'tenant456'.
     * @principle Enforces tenant-level access control for tables, allowing admin_kafe users to manage tables within their tenant.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get: if isAdminKafe(tenantId);
      allow list: if false;
      allow create: if false;
      allow update: if isAdminKafe(tenantId);
      allow delete: if false;
    }

     /**
      * @description This collection stores documents indicating superadmin role. Existence of a document for a user ID implies superadmin privileges. Locked from client-side writes.
      * @path /roles_superadmin/{userId}
      * @allow (get) User with ID 'superadmin_user' (superadmin) can access their own role document.
      * @deny (create) No one can create documents in this collection.
      * @deny (update) No one can update documents in this collection.
      * @deny (delete) No one can delete documents in this collection.
      * @principle Only superadmins can read their own role document. No one else can create, update, or delete documents in this collection.
      */
    match /roles_superadmin/{userId} {
        allow get: if isOwner(userId);
        allow list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
  }
}