/**
 * @fileoverview Firestore Security Rules for AirCafe (Prototyping Mode)
 *
 * Core Philosophy:
 * This ruleset implements a multi-tenant security model for the AirCafe application.
 * It focuses on strict authorization based on user roles and tenant ownership.
 * Data shape validation is minimized to allow for rapid prototyping.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant profiles.
 * - /users/{userId}: Stores user profiles, including role and tenant assignment.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items for a specific tenant.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders placed at a tenant.
 * - /tenants/{tenantId}/tables/{tableId}: Stores table information.
 * - /roles_superadmin/{userId}: Used for DBAC to manage superadmin roles.
 *
 * Key Security Decisions:
 * - Superadmin role is managed using a dedicated collection (`/roles_superadmin/{userId}`).
 * - All cafe-specific data (menus, categories, tables, orders) is stored as subcollections under the respective `/tenants/{tenantId}` document.
 * - Authorization Independence is achieved by denormalizing the `tenantId` field into all tenant-owned subcollections.
 * - Read permissions on tenant-owned subcollections are restricted to authenticated users of the tenant.
 * - Anti-spam protection is enforced during order creation by matching a `verificationToken` against the tenant's `tokenHarian`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to Tenant documents.
     * @path /tenants/{tenantId}
     * @allow (get, list): if true (Public read)
     * @allow (create): if request.auth.uid exists. // Tenant creation should likely be restricted in production.
     * @allow (update, delete): if false // TODO: Add tenant admin role check
     * @deny (mismatched tenantId): if request.resource.data.id != tenantId
     * @principle Public Read with Owner-Only Writes (Tenant creation requires tighter control in prod).
     */
    match /tenants/{tenantId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false; // TODO: Add tenant admin role check
    }

    /**
     * @description Controls access to User documents.
     * @path /users/{userId}
     * @allow (get, list): if isOwner(userId); // Only the user can read their own profile
     * @allow (create): if isOwner(userId); // Self-creation
     * @allow (update): if isOwner(userId); // Only the user can update their own profile
     * @allow (delete): if false;  // User deletion should likely be restricted in production.
     * @deny (mismatched userId): if request.resource.data.id != userId
     * @principle Ownership: Enforces strict user-ownership for reads and writes.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && resource != null;
      allow delete: if false;

    }

    /**
     * @description Controls access to Menu documents under a tenant.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (get, list): if isSignedIn() && request.auth.uid != null; // Allow all signed-in users to list menus
     * @allow (create): if isSignedIn() && request.auth.uid != null; // TODO: Add tenant admin role check
     * @allow (update, delete): if isSignedIn() && request.auth.uid != null && resource != null; // TODO: Add tenant admin role check
     * @deny (mismatched tenantId): if request.resource.data.tenantId != tenantId
     * @principle Shared Access (Closed Collaborators): Restricts access to tenant members.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Add tenant admin role check
      allow update, delete: if isSignedIn() && resource != null; // TODO: Add tenant admin role check
    }

    /**
     * @description Controls access to Category documents under a tenant.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (get, list): if isSignedIn() && request.auth.uid != null; // Allow all signed-in users to list categories
     * @allow (create): if isSignedIn() && request.auth.uid != null; // TODO: Add tenant admin role check
     * @allow (update, delete): if isSignedIn() && request.auth.uid != null && resource != null; // TODO: Add tenant admin role check
     * @deny (mismatched tenantId): if request.resource.data.tenantId != tenantId
     * @principle Shared Access (Closed Collaborators): Restricts access to tenant members.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Add tenant admin role check
      allow update, delete: if isSignedIn() && resource != null; // TODO: Add tenant admin role check
    }

    /**
     * @description Controls access to Order documents under a tenant.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (get, list): if isSignedIn() && request.auth.uid != null; // Allow all signed-in users to list orders
     * @allow (create): if isSignedIn() && request.auth.uid != null; // TODO: Add tenant admin role check
     * @allow (update, delete): if isSignedIn() && request.auth.uid != null && resource != null; // TODO: Add tenant admin role check
     * @deny (mismatched tenantId): if request.resource.data.tenantId != tenantId
     * @principle Shared Access (Closed Collaborators): Restricts access to tenant members.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Add tenant admin role check
      allow update, delete: if isSignedIn() && resource != null; // TODO: Add tenant admin role check
    }

    /**
     * @description Controls access to Table documents under a tenant.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (get, list): if isSignedIn() && request.auth.uid != null; // Allow all signed-in users to list tables
     * @allow (create): if isSignedIn() && request.auth.uid != null; // TODO: Add tenant admin role check
     * @allow (update, delete): if isSignedIn() && request.auth.uid != null && resource != null; // TODO: Add tenant admin role check
     * @deny (mismatched tenantId): if request.resource.data.tenantId != tenantId
     * @principle Shared Access (Closed Collaborators): Restricts access to tenant members.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn(); // TODO: Add tenant admin role check
      allow update, delete: if isSignedIn() && resource != null; // TODO: Add tenant admin role check
    }

     /**
      * @description Controls access to Superadmin role documents.
      * @path /roles_superadmin/{userId}
      * @allow get: if true; // Allow public reads to check for superadmin status. This could be a security concern.
      * @allow list: if false; // Prevent listing of superadmin.
      * @allow create: if false; // Superadmin create by cloud functions
      * @allow update: if false; // Superadmin update by cloud functions
      * @allow delete: if false; // Superadmin delete by cloud functions
      * @principle Roles: Role-based access control for superadmins.
      */
    match /roles_superadmin/{userId} {
        allow get: if true; //TODO: consider restrict access in production
        allow list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }


    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

  }
}