/**
 * @fileoverview Firestore Security Rules for AirCafe application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model where users (admins) can only
 * access data within their assigned tenant. Superadmins have full access to all data.
 * Anonymous users can create orders after verification using a daily token.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores cafe (tenant) profiles and configurations.
 * - /users/{userId}: Stores user information, including role and tenantId.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items for a specific tenant.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories for a specific tenant.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders for a specific tenant.
 * - /tenants/{tenantId}/tables/{tableId}: Stores table information for a specific tenant.
 * - /roles_superadmin/{userId}: Stores superadmin role indicators.
 *
 * Key Security Decisions:
 * - Superadmins have full CRUD access to /tenants and /users collections.
 * - Regular admins (admin_kafe) are restricted to their own tenant's data.
 * - Orders can be created by unauthenticated users after token verification.
 * - Listing of all tenants is disabled to prevent unauthorized discovery.
 * - Users collection listing is disabled.
 *
 * Denormalization for Authorization:
 * - Tenant ID is denormalized into the Order, Menu, Category, and Table documents to simplify authorization rules.
 * - User documents store their tenantId for quick role-based access checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @param {void}
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is a superadmin.
     * @param {void}
     * @return {boolean} True if the user is a superadmin, false otherwise.
     */
    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    /**
     * @description Checks if the user is the owner of the document based on the user ID.
     * @param {string} userId The user ID to compare with the authenticated user's UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     * @example isOwner('ttFbsVWt14cdTwVlKs1AbgBLUtx1')
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

   /**
     * @description Checks if the user is the owner of the existing document and that the document exists.
     * @param {string} userId The user ID to compare with the authenticated user's UID.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     * @example isExistingOwner('ttFbsVWt14cdTwVlKs1AbgBLUtx1')
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && getSelf().data != null;
    }

    /**
     * @description Gets the current authenticated user document
     * @return {Resource} The user document for the current authenticated user.
     */
    function getSelf() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }

    /**
     * @description Checks if the user is an admin_kafe for a specific tenant.
     * @param {string} tenantId The tenant ID to check against the user's tenantId.
     * @return {boolean} True if the user is an admin_kafe for the tenant, false otherwise.
     */
    function isAdminKafe(tenantId) {
      return isSignedIn() && getSelf().data.tenantId == tenantId;
    }

    /**
     * @description Enforces that the incoming data includes the correct tenantId for admin_kafe users.
     * @param {string} tenantId The tenant ID that must match the incoming data's tenantId.
     * @return {boolean} True if the tenantId matches or the user is a superadmin, false otherwise.
     */
    function validateTenantId(tenantId) {
      return isSuperAdmin() || request.resource.data.tenantId == tenantId;
    }

    /**
     * @description Enforces that the existing document includes the correct tenantId for admin_kafe users.
     * @param {string} tenantId The tenant ID that must match the incoming data's tenantId.
     * @return {boolean} True if the tenantId matches or the user is a superadmin, false otherwise.
     */
    function validateExistingTenantId(tenantId) {
      return isSuperAdmin() || resource.data.tenantId == tenantId;
    }

    /**
     * @description Validates the verification token against the tenant's daily token.
     * @return {boolean} True if the tokens match, false otherwise.
     */
    function isValidVerificationToken() {
        return request.resource.data.verificationToken == get(/databases/$(database)/documents/tenants/$(request.resource.data.tenantId)).data.tokenHarian;
    }

    /**
     * @description
     *  - This rule applies to the /tenants/{tenantId} collection.
     *  - Superadmins can perform CRUD operations.
     *  - Tenant admins can update their own tenant document.
     * @path /tenants/{tenantId}
     * @allow (create) - Superadmin creates a new tenant.
     * @allow (update) - Superadmin updates any tenant, or tenant admin updates their own tenant.
     * @deny (create) - Non-superadmin attempts to create a tenant.
     * @deny (update) - Tenant admin attempts to update another tenant.
     * @principle Enforces role-based access control for tenant management.
     */
    match /tenants/{tenantId} {
      allow get: if true; // Public read
      allow list: if false;

      allow create: if isSuperAdmin();
      allow update: if isSuperAdmin() || (isSignedIn() && isAdminKafe(tenantId));
      allow delete: if isSuperAdmin();
    }

    /**
     * @description
     *  - This rule applies to the /users/{userId} collection.
     *  - Superadmins can perform CRUD operations.
     *  - Users can only create their own user document (self-registration).
     * @path /users/{userId}
     * @allow (create) - Superadmin creates a new user, or a user creates their own profile.
     * @allow (update) - Superadmin updates any user.
     * @deny (create) - Non-superadmin attempts to create a user for someone else.
     * @deny (update) - Non-superadmin attempts to update a user.
     * @principle Enforces role-based access control for user management.
     */
    match /users/{userId} {
      allow get: if isSuperAdmin() || isOwner(userId);
      allow list: if false;

      allow create: if isSuperAdmin() || isOwner(userId);
      allow update: if isSuperAdmin() || isOwner(userId);
      allow delete: if isSuperAdmin();
    }

    /**
     * @description
     *  - This rule applies to the /tenants/{tenantId}/menus/{menuId} collection.
     *  - Tenant admins can perform CRUD operations within their own tenant.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (create) - Tenant admin creates a new menu item within their tenant.
     * @allow (update) - Tenant admin updates a menu item within their tenant.
     * @deny (create) - Tenant admin attempts to create a menu item in another tenant.
     * @deny (update) - Tenant admin attempts to update a menu item in another tenant.
     * @principle Enforces tenant-based access control for menu management.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get: if true; // Public read
      allow list: if true;
      allow create: if isSignedIn() && isAdminKafe(tenantId);
      allow update: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
      allow delete: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
    }

    /**
     * @description
     *  - This rule applies to the /tenants/{tenantId}/categories/{categoryId} collection.
     *  - Tenant admins can perform CRUD operations within their own tenant.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (create) - Tenant admin creates a new category within their tenant.
     * @allow (update) - Tenant admin updates a category within their tenant.
     * @deny (create) - Tenant admin attempts to create a category in another tenant.
     * @deny (update) - Tenant admin attempts to update a category in another tenant.
     * @principle Enforces tenant-based access control for category management.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get: if true; // Public read
      allow list: if true;
      allow create: if isSignedIn() && isAdminKafe(tenantId);
      allow update: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
      allow delete: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
    }

    /**
     * @description
     *  - This rule applies to the /tenants/{tenantId}/orders/{orderId} collection.
     *  - Tenant admins can perform CRUD operations within their own tenant.
     *  - Anonymous users can create orders if the verification token matches the daily token.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (create) - Tenant admin or anonymous user with valid token creates a new order.
     * @allow (update) - Tenant admin updates an order within their tenant.
     * @deny (create) - Anonymous user with invalid token attempts to create an order.
     * @deny (update) - Tenant admin attempts to update an order in another tenant.
     * @principle Enforces tenant-based access control for order management, allows token-verified anonymous order creation.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get: if true; // Public read
      allow list: if true; // Public list
      allow create: if (isSignedIn() && isAdminKafe(tenantId)) || isValidVerificationToken();
      allow update: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
      allow delete: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
    }

    /**
     * @description
     *  - This rule applies to the /tenants/{tenantId}/tables/{tableId} collection.
     *  - Tenant admins can read and update tables within their own tenant.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (read) - Tenant admin reads a table within their tenant.
     * @allow (update) - Tenant admin updates a table within their tenant.
     * @deny (read) - Tenant admin attempts to read a table in another tenant.
     * @deny (update) - Tenant admin attempts to update a table in another tenant.
     * @principle Enforces tenant-based access control for table management.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get: if true; // Public read
      allow list: if true;
      allow create: if isSignedIn() && isAdminKafe(tenantId);
      allow update: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
      allow delete: if isSignedIn() && isAdminKafe(tenantId) && validateTenantId(tenantId);
    }

    /**
     * @description
     *  - This rule applies to the /roles_superadmin/{userId} collection.
     *  - Only the server can create/update/delete documents in this collection.
     *  - Existence of a document indicates superadmin privileges.
     * @path /roles_superadmin/{userId}
     * @allow (get) - Only superadmins can get roles.
     * @deny (create) - No client-side creation allowed.
     * @deny (update) - No client-side updates allowed.
     * @principle Restricts superadmin role management to the server.
     */
    match /roles_superadmin/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}