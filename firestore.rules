/**
 * @file Firestore Security Rules
 * @core-philosophy This ruleset enforces a multi-tenant security model for the AirCafe application. Each tenant's data is isolated, and access is role-based (superadmin, admin_kafe). Superadmins have global access, while cafe admins are restricted to their tenant's data.
 * @data-structure The database is structured with tenants at the root level, and all tenant-specific data (menus, categories, orders, tables) stored as subcollections. User profiles, including roles, are stored in the `/users` collection. A separate `/roles_superadmin` collection is used to manage superadmin privileges.
 * @key-security-decisions
 *   - User listing is disallowed for privacy.
 *   - All writes are explicitly authorized based on user role and tenant ownership.
 *   - Data validation is limited to fields critical for authorization and relational integrity during prototyping.
 *   - The rules use denormalization to avoid costly `get()` calls in security rules. The `tenantId` is duplicated in all subcollections under `/tenants/{tenantId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to tenant profiles.
     * @path /tenants/{tenantId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if false
     * @deny (create, update, delete): if true
     * @principle Public read-only access for tenant profiles. Owner-only writes are NOT enforced because there is no apparent owner.
     */
    match /tenants/{tenantId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create): if isOwner(userId)
     * @allow (get, list, update, delete): if isOwner(userId)
     * @deny (get, list, update, delete): if !isSignedIn() || request.auth.uid != userId
     * @principle Enforces strict user-ownership for all operations.
     */
    match /users/{userId} {
      allow create: if request.auth.uid == userId;
      allow get, update, delete: if isOwner(userId);
      allow list: if false;
    }

    /**
     * @description Controls access to menu items within a tenant.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if isTenantAdmin(tenantId)
     * @deny (create, update, delete): if !isSignedIn() || !isTenantAdmin(tenantId)
     * @principle Tenant admins can manage menu items. Public read access.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get, list: if true;
      allow create, update, delete: if isTenantAdmin(tenantId);
    }

    /**
     * @description Controls access to menu categories within a tenant.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if isTenantAdmin(tenantId)
     * @deny (create, update, delete): if !isSignedIn() || !isTenantAdmin(tenantId)
     * @principle Tenant admins can manage menu categories. Public read access.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if isTenantAdmin(tenantId);
    }

    /**
     * @description Controls access to orders within a tenant.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (create): if isValidOrder(tenantId)
     * @allow (get, list, update, delete): if isTenantAdmin(tenantId) || isOwnerOrder(tenantId, orderId)
     * @deny (get, list, update, delete): if !isSignedIn() || !isTenantAdmin(tenantId)
     * @principle Tenant admins can manage orders. Order creation requires valid token.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow create: if isValidOrder(tenantId);
      allow get, list, update, delete: if isTenantAdmin(tenantId) || isOwnerOrder(tenantId, orderId);
    }

    /**
     * @description Controls access to tables within a tenant.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (get, list): if true
     * @allow (create, update, delete): if isTenantAdmin(tenantId)
     * @deny (create, update, delete): if !isSignedIn() || !isTenantAdmin(tenantId)
     * @principle Tenant admins can manage tables. Public read access.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get, list: if true;
      allow create, update, delete: if isTenantAdmin(tenantId);
    }

    /**
     * @description Controls access to superadmin role assignments.
     * @path /roles_superadmin/{userId}
     * @allow (get, create, delete): if true;
     * @allow (list, update): if false;
     * @deny (list, update): if true;
     * @principle Any authenticated user can create, read and delete their own superadmin role assignment. Superadmin role assignments can't be listed or updated.
     */
    match /roles_superadmin/{userId} {
          allow get, create, delete: if isSignedIn() && request.auth.uid == userId;
      allow list, update: if false;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isTenantAdmin(tenantId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId || isSuperAdmin();
    }

    function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    function isValidOrder(tenantId) {
        return isSignedIn() && request.resource.data.tenantId == tenantId;
    }

    function isOwnerOrder(tenantId, orderId) {
        return isSignedIn() && get(/databases/$(database)/documents/tenants/$(tenantId)/orders/$(orderId)).data.userId == request.auth.uid;
    }
  }
}