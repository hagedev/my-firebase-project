/**
 * @file Firestore Security Rules for AirCafe
 * @version Prototyping
 *
 * @description
 * This ruleset enforces a multi-tenant security model for the AirCafe application. It provides fine-grained access control based on user roles (superadmin, admin_kafe) and data ownership. The primary goal is to ensure that users can only access and modify data within their assigned tenant or based on their role. Superadmins have unrestricted access.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant profiles, accessible by superadmins and the tenant's admin for updates.
 * - /users/{userId}: Stores user profiles, accessible by superadmins.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items for a tenant, managed by the tenant's admin.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories for a tenant, managed by the tenant's admin.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders for a tenant, managed by the tenant's admin, customers can create orders with verification.
 * - /tenants/{tenantId}/tables/{tableId}: Stores table information for a tenant, managed by the tenant's admin.
 * - /roles_superadmin/{userId}: Indicates superadmin privileges. Locked from client-side writes.
 *
 * Key Security Decisions:
 * - Strict tenant-based access control: admin_kafe users can only manage data within their assigned tenant.
 * - Superadmins have full CRUD access to all data.
 * - Customers can create orders if the verification token matches the current tenant's token.
 * - User listing is disallowed to prevent unauthorized access to user data.
 * - Data validation is relaxed in this prototyping phase to allow for rapid iteration.
 *
 * Denormalization for Authorization:
 * - Tenant IDs are denormalized across all tenant-specific collections (menus, categories, orders, tables) to simplify security rules and avoid complex queries.
 *
 * Structural Segregation:
 * - Separate collections are used for tenants, users, and tenant-specific data, providing a clear separation of concerns and simplifying access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access to tenant profiles. Superadmins can perform CRUD operations. Tenant admins can update their own tenant profile.
     * @path /tenants/{tenantId}
     * @allow (read, update, delete) User with superadmin role
     * @allow (update) User with admin_kafe role if updating their own tenant
     * @deny (create) All users (tenants are created via other means)
     * @deny (update, delete) User with admin_kafe role if not updating their own tenant
     * @principle Enforces role-based access control and tenant ownership.
     */
    match /tenants/{tenantId} {
      allow get: if true;
      allow list: if false;
      allow create: if false;
      allow update: if isSuperAdmin() || (isSignedIn() && isTenantAdminUpdatingOwnTenant(tenantId));
      allow delete: if isSuperAdmin();
    }

    /**
     * @description Manages access to user profiles. Only superadmins can perform CRUD operations.
     * @path /users/{userId}
     * @allow (create, read, update, delete) User with superadmin role
     * @deny All other users
     * @principle Enforces role-based access control.
     */
    match /users/{userId} {
      allow get: if isSuperAdmin();
      allow list: if false;
      allow create: if isSuperAdmin() && request.resource.data.id == request.auth.uid;
      allow update: if isSuperAdmin();
      allow delete: if isSuperAdmin();
    }

    /**
     * @description Manages access to menu items for a specific tenant. Only tenant admins can perform CRUD operations within their tenant.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow (create, read, update, delete) User with admin_kafe role within their tenant.
     * @deny All other users.
     * @principle Enforces tenant-based access control.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get: if isTenantAdmin(tenantId);
      allow list: if false;
      allow create: if isTenantAdmin(tenantId);
      allow update: if isTenantAdmin(tenantId);
      allow delete: if isTenantAdmin(tenantId);
    }

    /**
     * @description Manages access to menu categories for a specific tenant. Only tenant admins can perform CRUD operations within their tenant.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow (create, read, update, delete) User with admin_kafe role within their tenant.
     * @deny All other users.
     * @principle Enforces tenant-based access control.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get: if isTenantAdmin(tenantId);
      allow list: if false;
      allow create: if isTenantAdmin(tenantId);
      allow update: if isTenantAdmin(tenantId);
      allow delete: if isTenantAdmin(tenantId);
    }

    /**
     * @description Manages access to orders for a specific tenant. Tenant admins can perform CRUD operations. Customers can create orders with a valid verification token.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow (create, read, update, delete) User with admin_kafe role within their tenant.
     * @allow (create) Anonymous user with valid token.
     * @deny All other users.
     * @principle Enforces tenant-based access control and allows customer order creation with token verification.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get: if isTenantAdmin(tenantId) || isValidOrderCreation(tenantId);
      allow list: if false;
      allow create: if isTenantAdmin(tenantId) || isValidOrderCreation(tenantId);
      allow update: if isTenantAdmin(tenantId);
      allow delete: if isTenantAdmin(tenantId);
    }

    /**
     * @description Manages access to table information for a specific tenant. Tenant admins can read and update table information within their tenant.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow (read, update) User with admin_kafe role within their tenant.
     * @deny All other users.
     * @principle Enforces tenant-based access control.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get: if isTenantAdmin(tenantId);
      allow list: if false;
      allow create: if isTenantAdmin(tenantId);
      allow update: if isTenantAdmin(tenantId);
      allow delete: if isTenantAdmin(tenantId);
    }

     /**
      * @description Controls access to the superadmin role collection.  No client-side writes allowed.
      * @path /roles_superadmin/{userId}
      * @allow get: if isSuperAdmin();
      * @allow list: if false;
      * @allow create: if false;
      * @allow update: if false;
      * @allow delete: if false;
      * @principle Only the backend can manage superadmin roles.
      */
    match /roles_superadmin/{userId} {
        allow get: if isSuperAdmin();
        allow list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
  }

  // --- Helper functions ---

  /**
   * @description Checks if the user is signed in.
   * @return True if the user is signed in, false otherwise.
   */
  function isSignedIn() {
    return request.auth != null;
  }

  /**
   * @description Checks if the user is a superadmin.
   * @return True if the user is a superadmin, false otherwise.
   */
  function isSuperAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
  }

  /**
   * @description Checks if the user is an admin for the specified tenant.
   * @param {string} tenantId The ID of the tenant to check.
   * @return True if the user is an admin for the tenant, false otherwise.
   */
  function isTenantAdmin(tenantId) {
    return isSignedIn()
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin_kafe'
        && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
  }

  /**
   * @description Checks if the user is an admin for the specified tenant and is updating their own tenant.
   * @param {string} tenantId The ID of the tenant to check.
   * @return True if the user is an admin for the tenant and is updating their own tenant, false otherwise.
   */
  function isTenantAdminUpdatingOwnTenant(tenantId) {
    return isTenantAdmin(tenantId)
        && request.auth.uid == get(/databases/$(database)/documents/tenants/$(tenantId)).data.adminId;
  }

  /**
   * @description Validates the order creation request to ensure token verification.
   * @param {string} tenantId The ID of the tenant to check.
   * @return True if the token is valid, false otherwise.
   */
  function isValidOrderCreation(tenantId) {
      return request.resource.data.verificationToken == get(/databases/$(database)/documents/tenants/$(tenantId)).data.tokenHarian;
  }

  /**
   * @description Checks if the user is the owner of the resource.
   * @param {string} userId The user ID to compare against the resource's owner ID.
   * @return True if the user is the owner, false otherwise.
   */
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

    /**
    * @description Checks if the user is the owner of an existing resource.
    * @param {string} userId The user ID to compare against the resource's owner ID.
    * @return True if the user is the owner and the resource exists.
    */
   function isExistingOwner(userId) {
     return isOwner(userId) && resource.data != null;
   }
}