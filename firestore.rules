/**
 * @fileoverview Firestore Security Rules for AirCafe application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model. Tenants are isolated from each other,
 * with user access controlled by roles (superadmin, admin_kafe) and tenant assignments. Data
 * in subcollections is secured to the corresponding tenant.  Superadmins have full access.
 *
 * Data Structure:
 * - /tenants/{tenantId}: Stores tenant profiles.
 * - /users/{userId}: Stores user profiles, including role and tenant assignment.
 * - /tenants/{tenantId}/menus/{menuId}: Stores menu items for a tenant.
 * - /tenants/{tenantId}/categories/{categoryId}: Stores menu categories for a tenant.
 * - /tenants/{tenantId}/orders/{orderId}: Stores orders for a tenant.
 * - /tenants/{tenantId}/tables/{tableId}: Stores tables for a tenant.
 * - /roles_superadmin/{userId}: DBAC collection to indicate superadmin role.
 *
 * Key Security Decisions:
 * - Superadmins (defined in `/roles_superadmin/{userId}`) bypass tenant-level restrictions.
 * - The `tokenHarian` on the `Tenant` must match the `verificationToken` on an `Order` during creation.
 * - Data is denormalized (tenantId) onto subcollection documents to avoid extra reads in rules.
 * - Listing all tenants is denied to regular users.
 *
 * Denormalization for Authorization:
 * - `tenantId` is duplicated in all subcollections (menus, categories, tables, orders) to allow
 *   security rules to efficiently validate tenant-level access without requiring `get()` calls
 *   to the tenant document.
 *
 * Structural Segregation:
 * - Private user data is stored under `/users/{userId}`, separate from public tenant data, which
 *   is stored under `/tenants/{tenantId}`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure tenant profiles.  Superadmins can read all tenants; others are denied.
     * @path /tenants/{tenantId}
     * @allow get, list: if isAdmin();
     * @allow create: if false;
     * @allow update: if false;
     * @allow delete: if false;
     * @deny create: if true;
     * @deny update: if true;
     * @deny delete: if true;
     * @principle Restricts tenant listing to superadmins only.
     */
    match /tenants/{tenantId} {
      allow get, list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure user profiles.  Owners can read/write their own profile. Superadmins have full access.
     * @path /users/{userId}
     * @allow get, list: if isOwner(userId) || isAdmin();
     * @allow create: if isOwner(userId);
     * @allow update: if isExistingOwner(userId) || isAdmin();
     * @allow delete: if isExistingOwner(userId) || isAdmin();
     * @deny create: if !isOwner(userId);
     * @deny update: if !isExistingOwner(userId) && !isAdmin();
     * @deny delete: if !isExistingOwner(userId) && !isAdmin();
     * @principle Enforces user-ownership for data access, with superadmin override.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isOwner(userId) || isAdmin();
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) || isAdmin();
      allow delete: if isExistingOwner(userId) || isAdmin();
    }

    /**
     * @description Secure menu items for a tenant.  Tenant admins and superadmins have full access.
     * @path /tenants/{tenantId}/menus/{menuId}
     * @allow get, list: if isTenantAdmin(tenantId) || isAdmin();
     * @allow create: if isTenantAdmin(tenantId) || isAdmin();
     * @allow update: if isTenantAdmin(tenantId) || isAdmin();
     * @allow delete: if isTenantAdmin(tenantId) || isAdmin();
     * @deny create: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny update: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny delete: if !isTenantAdmin(tenantId) && !isAdmin();
     * @principle Enforces tenant-level access for menus.
     */
    match /tenants/{tenantId}/menus/{menuId} {
      allow get: if isTenantAdmin(tenantId) || isAdmin();
      allow list: if isTenantAdmin(tenantId) || isAdmin();
      allow create: if isTenantAdmin(tenantId) || isAdmin();
      allow update: if isTenantAdmin(tenantId) || isAdmin();
      allow delete: if isTenantAdmin(tenantId) || isAdmin();
    }

    /**
     * @description Secure menu categories for a tenant. Tenant admins and superadmins have full access.
     * @path /tenants/{tenantId}/categories/{categoryId}
     * @allow get, list: if isTenantAdmin(tenantId) || isAdmin();
     * @allow create: if isTenantAdmin(tenantId) || isAdmin();
     * @allow update: if isTenantAdmin(tenantId) || isAdmin();
     * @allow delete: if isTenantAdmin(tenantId) || isAdmin();
     * @deny create: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny update: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny delete: if !isTenantAdmin(tenantId) && !isAdmin();
     * @principle Enforces tenant-level access for categories.
     */
    match /tenants/{tenantId}/categories/{categoryId} {
      allow get: if isTenantAdmin(tenantId) || isAdmin();
      allow list: if isTenantAdmin(tenantId) || isAdmin();
      allow create: if isTenantAdmin(tenantId) || isAdmin();
      allow update: if isTenantAdmin(tenantId) || isAdmin();
      allow delete: if isTenantAdmin(tenantId) || isAdmin();
    }

    /**
     * @description Secure orders for a tenant. Tenant admins and superadmins have full access.  Order creation validates the token.
     * @path /tenants/{tenantId}/orders/{orderId}
     * @allow get, list: if isTenantAdmin(tenantId) || isAdmin();
     * @allow create: if isValidOrder(tenantId);
     * @allow update: if isTenantAdmin(tenantId) || isAdmin();
     * @allow delete: if isTenantAdmin(tenantId) || isAdmin();
     * @deny create: if !isValidOrder(tenantId);
     * @deny update: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny delete: if !isTenantAdmin(tenantId) && !isAdmin();
     * @principle Enforces tenant-level access for orders, with token validation on create.
     */
    match /tenants/{tenantId}/orders/{orderId} {
      allow get: if isTenantAdmin(tenantId) || isAdmin();
      allow list: if isTenantAdmin(tenantId) || isAdmin();
      allow create: if isValidOrder(tenantId);
      allow update: if isTenantAdmin(tenantId) || isAdmin();
      allow delete: if isTenantAdmin(tenantId) || isAdmin();
    }

    /**
     * @description Secure tables for a tenant. Tenant admins and superadmins have full access.
     * @path /tenants/{tenantId}/tables/{tableId}
     * @allow get, list: if isTenantAdmin(tenantId) || isAdmin();
     * @allow create: if isTenantAdmin(tenantId) || isAdmin();
     * @allow update: if isTenantAdmin(tenantId) || isAdmin();
     * @allow delete: if isTenantAdmin(tenantId) || isAdmin();
     * @deny create: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny update: if !isTenantAdmin(tenantId) && !isAdmin();
     * @deny delete: if !isTenantAdmin(tenantId) && !isAdmin();
     * @principle Enforces tenant-level access for tables.
     */
    match /tenants/{tenantId}/tables/{tableId} {
      allow get: if isTenantAdmin(tenantId) || isAdmin();
      allow list: if isTenantAdmin(tenantId) || isAdmin();
      allow create: if isTenantAdmin(tenantId) || isAdmin();
      allow update: if isTenantAdmin(tenantId) || isAdmin();
      allow delete: if isTenantAdmin(tenantId) || isAdmin();
    }

      /**
       * @description Grants superadmin privileges based on document existence in this collection.
       * @path /roles_superadmin/{userId}
       */
    match /roles_superadmin/{userId} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_superadmin/$(request.auth.uid));
    }

    function isTenantAdmin(tenantId) {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.tenantId == tenantId;
    }

      function isValidOrder(tenantId) {
          return isSignedIn()
              && request.resource.data.tenantId == tenantId
              && request.resource.data.verificationToken == get(/databases/$(database)/documents/tenants/$(tenantId)).data.tokenHarian;
      }
  }
}